#назва класів завжди CamelCase
#базовий клас це обжект
# class User(object):#базовий клас це обжект-можемо не писати воно і так є по замовчувані
class User:
    count = 0 # це зміна класу і до неї прийнято звертатися через ім'я класу навіть якщо є єекземпляр класу
# для того, щоб створити екземпляр класу нам потрібен конструктор тут замість конструктора є блок init-
# отже, це метод який починається з двох андескорів(__init__) далі можемо писати сюди що ми хочемо.(self, name, age)
#  self-це посилання на майбутнє створений екземпляр класу(посилання на контекст)
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f'{self.name} {self.age}' # str-перетворює напис в стрічку # Max 15
        #return str(self.__dict__) # переводить задопомоги конвертації в стрічку # {'name': 'Max', 'age': 15}
    def __repr__(self):     # створюю декілька екзе.класів
        return  self.__str__() #[Max 15, Olha 35]



print(User.count)
User.count = 10 # змінюємо її
print(User.count)
# створюємо екземпляр класу
user=User('Max', 15)
print(user)# він скаже що це клас User об'єкт, який лежить в такій частинці пам'яті
print(user.name)
print(user.age)
#print(user.count) через екземпляр класу не можна доступатися,так не можна робити
# до зміних самого класу звертаємося тільки через ім'я самого класу(user.name)
# класи в пайтоні не знають як їм реагувати на різноманітні речі тому числі і (print)-
# хочу строкове приставлення = це можна змінити-це перегрузка методів.
# Є метод str-ми програмуємо поведінку,як
# екземпляр класу має реагувати коли я хочу йго побачити у вигляді строки
# створюю декілька екзе.класів
users=[user, User('Olha', 35)]
