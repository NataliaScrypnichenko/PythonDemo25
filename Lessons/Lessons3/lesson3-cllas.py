# #назва класів завжди CamelCase
# #базовий клас це обжект
# # class User(object):#базовий клас це обжект-можемо не писати воно і так є по замовчувані
# class User:
#     __slots__ = ('name', 'age') # для не змінних полів і додавати нове поле
#     count = 0           # це зміна класу і до неї прийнято звертатися через ім'я класу навіть якщо є єекземпляр класу
#                         # для того, щоб створити екземпляр класу нам потрібен конструктор тут замість конструктора є блок init-
#                         # отже, це метод який починається з двох андескорів(__init__) далі можемо писати сюди що ми хочемо.(self, name, age)
#                         #  self-це посилання на майбутнє створений екземпляр класу(посилання на контекст)
#     def __init__(self, name, age):
#
#         self.name = name
#         self.age = age  # створюю поля екземплярів
#
#     def get_name(self):  # і можу ств методи різні
#         return self.name # повертає
#
#
#     def __str__(self):
#        # return f'{self.name} {self.age}' # str-перетворює напис в стрічку # Max 15
#         return str(self.__dict__) # переводить задопомоги конвертації в стрічку # {'name': 'Max', 'age': 15}
#     def __repr__(self):     # створюю декілька екзе.класів
#         return  self.__str__() #[Max 15, Olha 35]
#


# print(User.count) #
# User.count #  до зміник класу викликаємо так?екземпляр класу викликаємо тільки через ім'я
# user.count = 10 # змінюємо її
# print(User.count)
# class User:
#     count = 0
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age
# # створюємо екземпляр класу
# user=User('Max', 15)
# print(user)# він скаже що це клас User об'єкт, який лежить в такій частинці пам'яті,адрес
# print(user.name) # дивимося імя класу
# print(user.age)
# #print(user.count) через екземпляр класу не можна доступатися,так не можна робити
# # до зміних самого класу звертаємося тільки через ім'я самого класу(user.name)
# # класи в пайтоні не знають як їм реагувати на різноманітні речі тому числі і (print)-
# # print = хочу строкове приставлення = це можна змінити-це перегрузка методів.
# class User:
#     __slots__ = ('name', 'age') # додаємо поля які будуть дозволенні, не дозволяє додати інші поля
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age
#     count = 0
#
#     def __init__(self, name, age): # __hjjj__=(який склад. з 2х__андискорів Magic lg)називають методом
#             self.name = name
#             self.age = age
#  # ми створюємо поля екземпляру класу ми можемо створювати різні методи
#     def get_name(self):
#         return self.name # який повертає йому name
#  # print(user.get_name()) # тепер ми можемо його визвати  після ств.метода // (Max)
#     def __str__(self):      # Є метод str-ми програмуємо поведінку,як екземпляр класу має реагувати коли я хочу йго побачити у вигляді строки= тобто це повертаю щось
#        # return f'{self.name} {self.age}' # str-перетворює напис в стрічку # Max 15
#         return str(self.__dict__)  #звичайний -> в дікшері а якщо його обгорнути в () і написати перед  str  то переводить його  конвертації в стрічку # {'name': 'Max', 'age': 15}
# # # створюю декілька екзе.класів
# # users=[user, User('Olha', 35)] # ств.масив= перший це user-Макс  User-новий користувач
# #print(users) # дає посилання на адрес,це для дибагінгу= використовуємо другий метод
#     def __repr__(self):     # створюю декілька екзе.класів додаємо теж що і до str
#         return self.__str__() # це ми звертаемося до str і повертає те що в str методі,і викликали його і можемо його дебажити //{'name': 'Max', 'age': 15}, {'name': 'Olha', 'age': 35}
# # за звичай цей метод не пишуть def __repr__(self): або пишуть в парі з  def __str__(self): і def __repr__(self):
# # user.age= 99  # можна звернутися до віку і напряму його і  змінити його на інший
# # print(user) #  // {'name': 'Max', 'age': 99}
# # # user.house = 55 # звернуся до юзера і задам нове поле (house ) і викликаю user
# # print(user) # {'name': 'Max', 'age': 99, 'house': 55}-(це є проблема) і воно додається, щоб не додавалося
# # # ми використовуємо  __slots__ = ('name', 'age') яке додається в шапку і пишуться поля які повинні бути присутні

