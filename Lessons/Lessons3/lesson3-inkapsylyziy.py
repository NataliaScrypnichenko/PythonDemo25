# # інкапсуляція

class User:
    def __init__(self, name, age):
        self.__name = name # робиться приватними змінні (__name__)
        self._age = age
    def get_name(self):  #якщо я хочу доступ, то є доступ до __name через метод get_name і можна зробити його приватним __get_name
        return self.__name

user= User('Max', 15)
# print(user.__name)  якщо захочу до нього доступитися, він нічого не дасть
# ЯКА суть інкапсуляціїї -вона має під собою те, що ми скриваємо зміні від користувача, але відкриваємо доступ до цих змінних за допомогою якихось
# функцій і інтерфейсів. За то є доступ через метод
print(user.get_name()) # щоб отримати // Max
# отже для користувача закритий але за допомогою get_name(self) відкритий і можна зробити його приватним __get_name
# Приватні змінні можна використовувати тільки в середині класу ось тут---
#     def __init__(self, name, age):
#         self.__name = name
#         self.age = age
#     def get_name(self):
#         return self.__name
#є ще варіант це protected-з одним андискором- це означая self._age = age не буде показувати, але цією зміною можна користуватися в середині класу
# і в класах нащадках
print(user._age) #// 15 # можна вивести, але є фітча чи бага доступитися можна, дасть помилку, але виведе 15
# приватність умовна в пайтоні - завжди їх можна дістати змінні
# дістаю name звертаюся до ім'я єкземпляру user
# print(user._User__name) // Max # дає ім'я, його використовують в реальності
#14:59