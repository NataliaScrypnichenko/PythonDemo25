# # інкапсуляція

class User:
    count = 0 # він відноситься, до самого класу і належать йому
    def __init__(self, name, age):
        self.__name = name # робиться приватними змінні (__name__)
        self._age = age
    def get_name(self):  #якщо я хочу доступ, то є доступ до __name через метод get_name і можна зробити його приватним __get_name
        return self.__name

user= User('Max', 15)
# print(user.__name)  якщо захочу до нього доступитися, він нічого не дасть
# ЯКА суть інкапсуляціїї -вона має під собою те, що ми скриваємо зміні від користувача, але відкриваємо доступ до цих змінних за допомогою якихось
# функцій і інтерфейсів. За то є доступ через метод
print(user.get_name()) # щоб отримати // Max
# отже для користувача закритий але за допомогою get_name(self) відкритий і можна зробити його приватним __get_name
# Приватні змінні можна використовувати тільки в середині класу ось тут---
#     def __init__(self, name, age):
#         self.__name = name
#         self.age = age
#     def get_name(self):
#         return self.__name
#є ще варіант це protected-з одним андискором- це означая self._age = age не буде показувати, але цією зміною можна користуватися в середині класу
# і в класах нащадках
print(user._age) #// 15 # можна вивести, але є фітча чи бага доступитися можна, дасть помилку, але виведе 15
# приватність умовна в пайтоні - завжди їх можна дістати змінні
# дістаю name звертаюся до ім'я єкземпляру user
# print(user._User__name) // Max # дає ім'я, його використовують в реальності і отримали свою приватну зміну  Max

# Логічними і приватними може буди самі зміні самого класу
# print(User.__count) # print(user.__count)- не можна до нього доступитися, але можна зробити по іншому
# print(User._User__count)# // 0\\ до зміни класу можна доступитися тільки через самий клас User
user2=User('Max', 15)
user=User('Olha', 25)
User.count= 88
print(user2.count)# 88 отримати його через екземпляр класу то буде одне і те число.
print(user.count)# 88

